.TH sng 1 "" "Open Source"
.SH NAME
sng -- compiler/decompiler for Scriptable Network Graphics
.SH SYNOPSIS
sng [-iv] [file...]
.SH DESCRIPTION
The sng program tranlsates between PNG (Portable Network Graphics)
format and SNG (Scriptable Network Graphics) format.  SNG is a printable and
editable minilanguage for describing PNG files.

An SNG description consists of a series of chunk specifications in a
simple editable text format.  These generally correspond one-for-one
to PNG chunks.  There is one exception; the IMAGE chunk
specification is automatically translated into an IDAT chunk (doing
appropriate interlacing, compression, etcetera).

Given no file arguments, sng translates stdin to stdout.  In this
mode, it checks the first character. If that character is printable,
the input stream is assumed to contain SNG; sng tries to translate it
to PNG.  If the character is non-printable, the input stream is
assumed to contain PNG; sng tries to translate it to SNG.

For each file that sng operates on, it does its conversion according
to the file extension (.png or .sng).  The result file has the same
name left of the dot as the original, but the opposite extension and
type.

There are two options.  The -i option causes IDAT chunks in a PNG to
be dumped in raw form as IDAT chanks rather than as a reassembled
IMAGE.  The -v option makes sng report on what files it is converting.
.SH SNG LANGUAGE SYNTAX
In general, the SNG language is token-oriented with tokens separated
by whitespace.  The characters `:' and `;' are treated as whitespace,
except the `;' terminates a data literal (see below).

In the syntax descriptions below, lines between {} may occur in any
order. Elements bracketed in [] are optional; a sequence bracketed by
[]* may be repeated any number of times.  Elements separated by | are
alternatives.  Elements separated by plus signs are an attribute set;
any sequence of one or more of those element tokens is valid.

The elements <byte>, <short>, <long>, <float>, <string> are byte
numeric, short-integer numeric, long-integer numeric, float numeric
literals respectively (all unsigned).  The <slong> element is a signed
long-numeric literal. All numerics use C conventions; that is, they
are decimal unless led by 0x (hex) or 0 (octal).

The element <string> is a doublequote-delimited character string.
C-style escapes (\en, \et, \rb, \r, \e followed by octal or hex digits)
are interpreted.  The element <keyword> is a doublequote-delimited PNG
keyword; that is, a string of no more than 79 printable Latin-1
characters or spaces, with no leading and no traling and no
consecutive spaces.

A <data> literal consists of a sequence of byte specifications in one
of three formats. String format is a doublequote-delimited printable
ASCII string.  The other two formats are signaled by the token `base64', or `hex'.
Base64 format can be used if the image either has total (color plus
alpha) bit depth of four or less, or it is a paletted image with 64 or
fewer colors; values of the chars are 0-9, followed by A-Z for 10-35,
followed by a-z for 36-61, followed by + for 62 and / for 63 (RFC2045
base-64 encoding).  In hex format, each byte is specified by two hex
digits (0123456789abcdef).  Whitespace embedded in base64 and hex data
literals is ignored.  A ';' ends a data literal (unless it occurs
inside the string syntax).

Comments in the syntax diagram describe intended semantics.
.nf
IHDR {
   height <long>
   width <long>
   bitdepth <byte> 
   [using color+palette+alpha]	# PNG color type information
   [with interlace]		# Adam7 assumed if interlacing on
}

PLTE {
   [(<byte>,<byte>,<byte>)]*	# Any number of RGB triples
}

IDAT {
   <data>
}

gAMA {<float>}

cHRM {
   white (<float>,<float>)      # White point x and y
   red (<float>,<float>)
   green (<float>,<float>)
   blue (<float>,<float>)
}

sRGB {<byte>}                   # Colorimetry intent, range 0-3

iCCP {                          # International Color Consortium profile
   name <keyword>
   profile <data>
}

sBIT {
   red <byte>                   # Color images only
   blue <byte>                  # Color images only
   green <byte>                 # Color images only
   gray <byte>                  # Grayscale images only
   alpha <byte>                 # Images with alpha only
}

bKGD {
   red <short>                  # Color images only
   blue <short>                 # Color images only
   green <short>                # Color images only
   gray <short>                 # Grayscale images only
   index <byte>                 # Paletted images only
}

hIST {
   <short> [, <short>]*         # Count must match palette size
}

tRNS {
   [gray <short>]               # Grayscale images only
   [red <short>]                # True-color images only
   [green <short>]              # True-color images only
   [blue <short>]               # True-color images only
   [<byte>]*                    # Paletted images only
}

pHYs {
   xpixels <long>
   ypixels <long>
   [per meter]
}

tIME {
   year <short>
   month <byte>
   day <byte>
   hour <byte>
   minute <byte>
   second <byte>
}

tEXt {                          # Ordinary text chunk
  keyword <keyword>
  text <string>
}

zTXt {                          # Compressed text chunk
  keyword <keyword>
  text <string>
}

iTXt {                          # International UTF-8 keyword
  language <keyword>
  keyword <keyword>
  translated <keyword>          # Translation of the keyword
  text <string>
  [compressed]
}

oFFs {
  xoffset <slong>
  yoffset <slong> 
  [unit pixels|micrometers]*
}

sPLT {
   name <keyword>
   depth <byte>
   [(<short>, <short>, <short>, <short>, <short>)]*
}

pCAL {
   name <keyword>
   x0 <slong>
   x1 <slong>
   mapping linear|euler|exponential|hyperbolic
   unit <string>
   [parameters <string>] 
}

sCAL {
   unit meter|radian
   width <string>
   height <string>
}

IMAGE {
   <data>
}

gIFg {
   disposal <byte>
   input <byte>
   delay <short>
}

gIFx {
   identifier <string>                # Must be 8 characters
   code <string>                      # Must be 3 characters
   data <data>
}

private <string> {                    # Private chunk declaration
   <data>
}
.fi
.SH BUGS
The -i option doesn't work yet.  See the distribution TODO file
for other minor problems.
.SH AUTHOR
Eric S. Raymond <esr@snark.thyrsus.com> December 1999 (home page at
http://www.tuxedo.org/~esr/).


